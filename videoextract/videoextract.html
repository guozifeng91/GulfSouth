<!DOCTYPE html>
<html lang="en" dir="ltr">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Data extract from videos</title>
    <!-- tensorflow -->
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@2.0.0/dist/tf.min.js"></script>
    <script type="text/javascript">
      let tfmodel;
    </script>
    <style media="screen">
      *{
        font-family: sans-serif;
      }
      .header{
        font-size:32px;
        margin:1em;
      }
      .clicks{
        font-size:18px;
        min-width:10em;
      }
      .op_container{
        width:100%;
        display:flex;
        flex-direction:row;
        gap:2em;
        margin-top:2em;
        flex-wrap: wrap;
        justify-content: space-between;
      }
      .img_container{
        width:100%; display:flex; flex-direction:row; gap:1em;
      }
      .img_wrapper{
        position:relative; width:100%;
      }
      .display-section{
        position:relative;
        text-align:center;
        margin-left: auto;
        margin-right: auto;
        max-width: 720px;
      }
    </style>
  </head>
  <body>
    <div class="display-section">
      <div class="header">Extracting image data using AI</div>
      <!-- the real image data, for fixed input size -->
      <img id="input" crossorigin="anonymous" src="" width="513px" height="513px" hidden="hidden">
      <div id="image-section" class="img_container">
        <!-- the preview image data -->
        <div class="img_wrapper">
        <img id="input-preview" crossorigin="anonymous" src="https://upload.wikimedia.org/wikipedia/commons/3/3a/Cat03.jpg" style="max-width:100%; aspect-ratio:1">
        </div>
        <div class="img_wrapper">
        <canvas id="output" width="513px" height="513px" style="max-width:100%; border: solid 1px black;"></canvas>
        </div>
      </div>
      <textarea id="output-info" readonly="readonly" style="width:99%; padding:0.5%; height:20vh" ></textarea>
      <input type="file" accept="image/jpeg" id="input-file" multiple="multiple" hidden="hidden"></input>
      <div id="operation-section" class="op_container">
        <input type="button" id="get-files" value="open" class="clicks"></input>
        <input type="button" id="get-obj" value="process" class="clicks"></input>
        <input type="button" id="export-data" value="save" class="clicks"></input>
      </div>
    </div>

    <!-- reading exif inf. from files (GPS coordinate) -->
    <script type="text/javascript" src="../lib/exif-js/exif.js"></script>
    <script type="text/javascript">
      let files_to_process=[];
      let file_metas={};

      function clear_all(){files_to_process=[];file_metas={};}

      const INPUT_IMG = document.getElementById("input");
      const INPUT_IMG_PREV = document.getElementById("input-preview");
      const COUTPUT_CANVAS = document.getElementById('output');
      const OUTPUT_INFO = document.getElementById('output-info');

      const INDEXED_COLORS={
        0:[0,0,0,255],
        1:[255,0,0,255],
        2:[255,255,0,255],
        3:[255,255,255,255],
        4:[0,255,0,255],
        5:[0,255,255,255],
        6:[0,0,255,255],
        7:[255,0,255,255],
      };

      function render_raster(ctx, rst, h=513, w=513, cmap=(x)=>{return INDEXED_COLORS[x%8];}){
        // render raster data to RGB
        let imgData = ctx.getImageData(0, 0, w, h);
        for (let i=0; i<h; i++){ // y
          for (let j=0; j<w; j++){ // x
            const index_rst = (i*w + j);
            const index_px = index_rst * 4;
            const px = cmap(rst[index_rst]);
            imgData.data[index_px]=px[0];
            imgData.data[index_px+1]=px[1];
            imgData.data[index_px+2]=px[2];
            imgData.data[index_px+3]=px[3];
          }
        }
        ctx.putImageData(imgData, 0, 0);
      }

      function to_decimal(n){
        return n;
      }

      function cbk_get_GPS(f, cbk_next=null){
        // returns a callabel which extract gps data from f, and invoke cbk_next if non-null is given
        // note that EXIF works as callback functions
        return function(){
          EXIF.getData(f, function(){
            // console.log(EXIF.pretty(this));
            const lat = EXIF.getTag(this, "GPSLatitude") || null;
            const lon = EXIF.getTag(this, "GPSLongitude") || null;
            const bearing = EXIF.getTag(this, "GPSImgDirection") || EXIF.getTag(this, "GPSDestBearing") || null;
            const timestamp=EXIF.getTag(this, "GPSTimeStamp") || null;
            file_metas[f.name] = {'lat': to_decimal(lat), 'lon': to_decimal(lon), 'heading': bearing, 'time': timestamp};
            if (cbk_next!=null){
              cbk_next();
            }
          });
        };
      }

      function cbk_load_img(f, cbk_next=null){
        // returns a callabel which reads image data from f, and invoke cbk_next if non-null is given
        return function(){
          OUTPUT_INFO.value+=('\nprocessing '+f.name + ' ...');
          OUTPUT_INFO.scrollTop = OUTPUT_INFO.scrollHeight;
          const url= URL.createObjectURL(f);
          INPUT_IMG.src = url;
          INPUT_IMG_PREV.src=url;

          INPUT_IMG.onload = function(){
            URL.revokeObjectURL(this.src);
            if (cbk_next!=null){
              cbk_next();
            }
          };
        };
      }

      function cbk_run_prediction(cbk_next=null){
        // returns a callabel which process the current data of <img>, and invoke cbk_next if non-null is given
        return function(){
          const img = INPUT_IMG;
          const x = tf.tidy(()=>{
            return tf.browser.fromPixels(img).cast('int32').expandDims(0);
          });

          const y = tf.tidy(()=>{
            return tfmodel.execute(x).squeeze().argMax(2);
          });
          render_raster(COUTPUT_CANVAS.getContext('2d'), y.dataSync());

          if (cbk_next!=null){
            cbk_next();
          }
        };
      }

      function reg_ops(){
        // file API, which reads images (and more) from local drive
        // see https://developer.mozilla.org/en-US/docs/Web/API/File_API/Using_files_from_web_applications
        document.getElementById("get-files").addEventListener("click", function(){document.getElementById("input-file").click();}, false);

        document.getElementById("input-file").addEventListener("change", function(){
          clear_all();
          files_to_process=this.files;
          OUTPUT_INFO.value="==== " + this.files.length + " image(s) to process ====";
        }, false);

        document.getElementById('get-obj').onclick=function(){
          // build a chain of callback functions such that the files will be processed one after the other
          let cbk_chain=function(){
            OUTPUT_INFO.value+=('\n==== finished ====');
            OUTPUT_INFO.scrollTop = OUTPUT_INFO.scrollHeight;
          };

          if (files_to_process.length){
            // generate the callback chain from the selected files
            for (let file of files_to_process){ // for each of the returned files
              cbk_chain = cbk_get_GPS(file, cbk_chain);
              cbk_chain = cbk_run_prediction(cbk_chain);
              cbk_chain = cbk_load_img(file, cbk_chain);
            }
            cbk_chain();
          } else {
            // alert("please select image files from your local drive first");
            OUTPUT_INFO.value=('open first');
          }
        };
      }
    </script>

    <script type="module">
      OUTPUT_INFO.value=('loading...');
      tf.loadGraphModel("../models/deeplabv3_mnv2_dm05_pascal_trainval/web/model.json").then((x)=>{
        tfmodel=x;
        reg_ops();
        OUTPUT_INFO.value=('ready');
      });
    </script>
  </body>
</html>
